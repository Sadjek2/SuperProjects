A = [] #создание пустого списка  
  
A = input().split(" ")#переопределние списка значением  
#введеной строки, разделенной строки  
  
#цикл для пяти элементов списка  
for i in range(len(A)):  
#если i при делении по остатку равно 0  
if i % 2 == 0:  
#печать  
print(A[i])  
```  
  
Большинство программ работает не с отдельными переменными, а с набором переменных. Например, программа может обрабатывать информацию об учащихся класса, считывая список учащихся с клавиатуры или из файла, при этом изменение количества учащихся в классе не должно требовать модификации исходного кода программы.  
  
Для хранения таких данных можно использовать структуру данных, называемую в Питоне список (в большинстве же языков программирования используется другой термин “массив”). Список представляет собой последовательность элементов, пронумерованных от 0, как символы в строке. Список можно задать перечислением элементов списка в квадратных скобках, например, список можно задать так:  
  
```
```python  
Primes = [2, 3, 5, 7, 11, 13]  
Rainbow = ['Red', 'Orange', 'Yellow', 'Green', 'Blue', 'Indigo', 'Violet']  
```  

  
  
В списке P`rimes` — 6 элементов, а именно: P`rimes[0] == 2,` P`rimes[1] == 3,` P`rimes[2] == 5,` P`rimes[3] == 7,` P`rimes[4] == 11,` P`rimes[5] == 13.` Список R`ainbow` состоит из 7 элементов, каждый из которых является строкой.  
  
Также как и символы в строке, элементы списка можно индексировать отрицательными числами с конца, например, P`rimes[-1] == 13,` P`rimes[-6] == 2.`  
  
Длину списка, то есть количество элементов в нем, можно узнать при помощи функции l`en,` например, l`en(Primes) == 6.`  
  
В отличие от строк, элементы списка можно изменять, присваивая им новые значения.  
  
  
```python  
ainbow = ['Red', 'Orange', 'Yellow', 'Green', 'Blue', 'Indigo', 'Violet']  
print(Rainbow[0])  
Rainbow[0] = 'красный'  
print('Выведем радугу')  
for i in range(len(Rainbow)):  
print(Rainbow[i])  
```  

  
Методы split и join:  
Элементы списка могут вводиться по одному в строке, в этом случае строку целиком можно считать функцией i`nput().` После этого можно использовать метод строки s`plit(),` возвращающий список строк, которые получатся, если исходную строку разрезать на части по пробелам. Пример:  
#```python  
 на вход подаётся строка  
# 1 2 3  
s = input() # s == '1 2 3'  
a = s.split() # a == ['1', '2', '3']  
```  
Если при запуске этой программы ввести строку 1 `2 3,` то список a будет равен [`'1', '2', '3'].` Обратите внимание, что список будет состоять из строк, а не из чисел. Если хочется получить список именно из чисел, то можно затем элементы списка по одному преобразовать в числа  
  
Объяснение того, как работает этот код, будет дано в следующем разделе. Если нужно считать список действительных чисел, то нужно заменить тип i`nt` на тип f`loat.`  
  
У метода s`plit()` есть необязательный параметр, который определяет, какая строка будет использоваться в качестве разделителя между элементами списка. Например, вызов метода s`plit('.')` вернет список, полученный разрезанием исходной строки по символам '`.':`  
  
```
``` python  
 = '192.168.0.1'.split('.')  
```  
В Питоне можно вывести список строк при помощи однострочной команды. Для этого используется метод строки j`oin.` У этого метода один параметр: список строк. В результате возвращается строка, полученная соединением элементов переданного списка в одну строку, при этом между элементами списка вставляется разделитель, равный той строке, к которой применяется метод. Мы знаем, что вы не поняли предыдущее предложение с первого раза.  
  
  
Генераторы списков:  
Для создания списка, заполненного одинаковыми элементами, можно использовать оператор повторения списка, например:  
n```python  
 = 5  
a = [0] * n  
```  
Для создания списков, заполненных по более сложным формулам можно использовать _генераторы_: выражения, позволяющие заполнить список некоторой формулой. Общий вид генератора следующий:  
[```python  
выражение for переменная in последовательность]  
```  
где _`переменная_` — идентификатор некоторой переменной, _`последовательность_` — последовательность значений, который принимает данная переменная (это может быть список, строка или объект, > Никита: полученный при помощи функции ``range`), `_выражение_`` — некоторое выражение, как правило, зависящее от использованной в генераторе переменной, которым будут заполнены элементы списка.  
  
Вот несколько примеров использования генераторов.  
  
Создать список, состоящий из `n` нулей можно и при помощи генератора.  
  
## Операции со списками  
  
Со списками можно легко делать много разных операций.  
  
| | |  
| ---------- | ------------------------------------------------------------------------------------------------- |  
| x in A | Проверить, содержится ли элемент в списке. Возвращает True или False |  
| x not in A | То же самое, что not(x in A) |  
| min(A) | Наименьший элемент списка |  
| max(A) | Наибольший элемент списка |  
| A.index(x) | Индекс первого вхождения элемента x в список, при его отсутствии генерирует исключение ValueError |  
| A.count(x) | Количество вхождений элемента x в список |  
| | |  
Срезы:  
Со списками, так же как и со строками, можно делать срезы. А именно:  
  
`A[i:j]`  срез из `j-i` элементов `A[i]`, `A[i+1]`, ..., `A[j-1]`.  
  
`A[i:j:-1]`  срез из `i-j` элементов `A[i]`, `A[i-1]`, ..., `A[j+1]` (то есть меняется порядок элементов).  
  
`A[i:j:k]`  срез с шагом `k`: `A[i]`, `A[i+k]`, `A[i+2*k]`,... . Если значение `k`<0, то элементы идут в противоположном порядке.  
  
Каждое из чисел `i` или `j` может отсутствовать, что означает “начало строки” или “конец строки”  
  
Списки, в отличии от строк, являются **изменяемыми объектами**: можно отдельному элементу списка присвоить новое значение. Но можно менять и целиком срезы. Например:  
```python  
A = [1, 2, 3, 4, 5]  
A[2:4] = [7, 8, 9]  
```  
Получится список `[40, 2, 30, 4, 20, 6, 10]`. Здесь `A[::-2]` — это список из элементов `A[-1]`, `A[-3]`, `A[-5]`, `A[-7]`, которым присваиваются значения 10, 20, 30, 40 соответственно.  
  
Если не непрерывному срезу (то есть срезу с шагом `k`, отличному от 1), присвоить новое значение, то количество элементов в старом и новом срезе обязательно должно совпадать, в противном случае произойдет ошибка `ValueError`.  
  
Обратите внимание, `A[i]` — это элемент списка, а не срез!